import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { DatabaseConfig } from 'src/config/configuration';

@Injectable()
export class CatsService {
  private cats: Array<string> = ['bob the cat', 'jim the cat'];

  constructor(private configService: ConfigService) {}

  findAll(): Array<string> {
    console.log(this.configService.getOrThrow<string>('DATABASE_PASSWORD')); //we can access env variables by their names in the .env file
    console.log(this.configService.get<string>('database.user')); //we can access env variables from env objects generated by our configFactory function
    console.log(this.configService.get<string>('http.port')); //this is from our yaml config file generated by a configurationYamlFactory function

    // we can get whole nested configuration object by using an interface as the type hint
    const database = this.configService.get<DatabaseConfig>('database');
    console.log(
      'user and pass from interface type hint: ',
      database.user,
      database.pass,
    );

    const defaultEnv = this.configService.get<string>(
      'database.uri',
      'localhost', // we can use the .get() method with a default value in case the env variable does not exist
    );
    console.log('default value when env does not exist: ', defaultEnv); // this will log 'localhost' because 'database.uri' env variable does not exist

    return this.cats;
  }
}
